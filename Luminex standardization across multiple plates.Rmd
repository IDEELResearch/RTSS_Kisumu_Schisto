---
title: "Luminex standardization across multiple plates"
author: "Sahal Thahir & Jeff Bailey"
date: "2024-04-04"
output:
  pdf_document: default
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}


knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set()
```

## Aim

This code aims to do create MFI scaling factors for individuals plates to standardize MFI values. Please run the [LuminexCompileExperiment_2024_03_07.Rmd](link) file. 


### R Markdown

This is an R Markdown document, areas that between the `{r}` frames that
are require manual entries as described in the **bolded text**. When
entries are completed, press the *knit* button at the top of the page.

```{=html}
<!-- *Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. #When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this with `and`* /
--->
```
```{=html}
<!--
DEVELOPER NOTES
#useful links BSA corrected-- <https://docs.google.com/spreadsheets/d/1kFEW7UqGGvfmOtYQq_AdP3V2w7LwdhDLpTHPmPaJGnM/edit#gid=1434210263>

#TODO: potential transplate normalization based on standards

-->
```
```{r Library loads, include=FALSE}
# No input required
            library(tidyverse)
            library(here)
```

#### Dependencies

-   `r R.version.string`
    -   `tidyverse` (v. `r packageVersion("tidyverse")`)
    -   `here` (v. `r packageVersion("here")`)


# Standard curves
### Generation of standards dataframe 
This code is extracting standards data from all plates. The list of `Plates` is listed bellow
```{r Generate standard dataframes, echo=FALSE, warning=FALSE}
# No input required
  # Run previous "code" files sequentially
       # List all R files in the "code" folder
        code_files <- list.files("code", pattern = "*.R", full.names = TRUE)
        
        # Sort the files based on names (01, 02, 03, etc. )
          code_files <- sort(code_files)
        
        # Source each R file sequentially
        for (file in code_files) {
          source(file)
        }
  # Creation of standards dataframes ----
      #standards_df: all standards data from all paltes
          # Extract standards from all_plates_df
            standards_df <- all_plates_df[grep("Standard", all_plates_df$Sample), ]
          
          # Create Dilution factor column
            standards_df <- standards_df %>%
              mutate(Dilution_Factor = -as.numeric(str_extract(Sample, "\\d+")))

              # Move Dilution_Factor column to the second position
                standards_df <- standards_df %>%
                  select(Sample, Dilution_Factor, everything())  
          
          # Categorize MFI columns
            standard_mfi_cols <- names(standards_df)[sapply(standards_df, is.numeric) & names(standards_df) != "Dilution_Factor"]
          
          # Extract the part of the column name after "_"
            mfi_names <- gsub(".*_", "", standard_mfi_cols)
          
          # Gather MFI columns into long format
            standard_mfi_df <- tidyr::gather(standards_df, key = "Ab_Ag", value = "MFI", all_of(standard_mfi_cols))
          
          # Create Antigen groups
            standard_mfi_df <- standard_mfi_df %>%
              mutate(Antigen = gsub(".*_", "", Ab_Ag))
            
          #Create Plate column
              # Function to get Plate value for each row
                get_plate_value <- function(row) {
                  non_empty_values <- na.omit(row)
                  if (length(non_empty_values) == 0) {
                    return(NA_character_)
                  } else {
                    return(non_empty_values[1])
                  }
                }
              # Identify columns containing "Plate_"
                plate_cols <- grep("Plate_", names(standards_df), value = TRUE)
              
              # Create Plate column in standard_mfi_df
                standard_mfi_df <- standard_mfi_df %>%
                  mutate(Plate = apply(standard_mfi_df[plate_cols], 1, get_plate_value))
  
             # Create Antigen and Subclass columns based on Ab_Ag column
                standard_mfi_df <- standard_mfi_df %>%
                  mutate(
                    Subclass = sub("_.+", "", Ab_Ag),  # Extract what's before the "_"
                    Antigen = sub(".+_", "", Ab_Ag)    # Extract what's after the "_"
                  )
# show Plates 
    print(unique(standard_mfi_df$Plate))
    
```

# Standard plots
### Plot 1
This is a scatterplot of all standards across the plates listed above

```{r echo=FALSE, warning=FALSE}
# Generate plots ----
    # All plates- scatterplot based on Antigen

    ggplot(standard_mfi_df, aes(x = Dilution_Factor, y = log10(MFI), color = Antigen)) +
  geom_point() +
  labs(x = "Dilution Factor", y = "log10(MFI)", color = "Antigen") +
  ggtitle("MFI Standard curve based on Plates")

```

### Plot 2
This is the standard curve for each antigen. Pick which curve behaves logarithmically.

```{r Antigen standard curves, echo=FALSE, warning=FALSE}
    # Standard curves for each antigen
 plots <- standard_mfi_df %>%
  split(.$Antigen) %>%
  map(~ ggplot(.x, aes(x = Dilution_Factor, y = log10(MFI), color = Subclass)) +
        geom_point() +
        labs(x = "Dilution Factor", y = "log10(MFI)", color = "Subclass") +
        ggtitle(paste("MFI Standard curve for Antigen:", unique(.x$Antigen))))

# Print the plots
plots
```

# Standardization
For our study, I think we should use `AMA1` only. These are the plots based on `Subclass` type. It seems Subclass influences the behavior of the curves but all seem to respond logarithmically. 

```{r warning=FALSE}

    # Filter data for AMA-1 antigen
    ama1_data <- standard_mfi_df %>% 
      filter(Antigen == "HRPII")

# Filter out rows with zero dilution factor or NA MFI
ama1_data <- ama1_data %>% 
  filter(Dilution_Factor != 0 & !is.na(MFI))

# Create scatterplot with filtered data and facet by Subclass
ama1_plot <- ggplot(ama1_data, aes(x = Dilution_Factor, y = log10(MFI))) +
  geom_point(aes(color = Subclass)) +
  geom_smooth(method = "lm", formula = y ~ log(x), se = FALSE) +  # Add logarithmic line of best fit
  labs(x = "Dilution Factor", y = "log10(MFI)", color = "Subclass") +
  ggtitle("MFI Standard Curve for AMA1 based on Subclass") +
  theme_minimal() +
  facet_wrap(~ Subclass, scales = "free_y")

# Print the plot
print(ama1_plot)


```

## Standardization based on Subclass type for AMA1

```{r warning=FALSE}
# Split data by Subclass
ama1_data_split <- split(ama1_data, ama1_data$Subclass)

# Create a list to store plots
ama1_plots <- list()

# Create scatterplot for each Subclass level with a logarithmic regression line
for (Subclass_level in names(ama1_data_split)) {
  ama1_plots[[Subclass_level]] <- ggplot(ama1_data_split[[Subclass_level]], aes(x = Dilution_Factor, y = log10(MFI), color = Plate)) +
    geom_point(na.rm = TRUE) +
    geom_smooth(method = "lm", formula = y ~ log(x), se = FALSE, na.rm = TRUE) + # Add logarithmic regression line
    labs(x = "Dilution Factor", y = "log10(MFI)", color = "Plate") +
    ggtitle(paste("MFI Standard Curve for AMA1 - Subclass:", Subclass_level)) +
    theme_minimal()
}

# Print each plot in the list
for (i in seq_along(ama1_plots)) {
  print(ama1_plots[[i]])
}
```

# MFI Correction
Pick a `Dilution_Factor` value that is within the linear range of the curve. This will be the `Reference_Dilution` 
For this study, we will use *-3* 
This reference dilution is used to calculate the `Correction_Factor`




