---
title: "Luminex standardization across multiple plates"
author: "Sahal Thahir & Jeff Bailey"
date: "2024-04-04"
output:
  pdf_document: default
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}


knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set()
```

## Aim

This code aims to do create MFI scaling factors for individuals plates to standardize MFI values. Please run the [LuminexCompileExperiment_2024_03_07.Rmd](link) file. 


### R Markdown

This is an R Markdown document, areas that between the `{r}` frames that
are require manual entries as described in the **bolded text**. When
entries are completed, press the *knit* button at the top of the page.

```{=html}
<!-- *Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. #When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this with `and`* /
--->
```
```{=html}
<!--
DEVELOPER NOTES
#useful links BSA corrected-- <https://docs.google.com/spreadsheets/d/1kFEW7UqGGvfmOtYQq_AdP3V2w7LwdhDLpTHPmPaJGnM/edit#gid=1434210263>

#TODO: potential transplate normalization based on standards

-->
```
```{r Library loads, include=FALSE}
# No input required
            library(tidyverse)
            library(here)
            library(ggpubr)
```

#### Dependencies

-   `r R.version.string`
    -   `tidyverse` (v. `r packageVersion("tidyverse")`)
    -   `here` (v. `r packageVersion("here")`)


# Standard curves
### Generation of standards dataframe 
This code is extracting standards data from all plates. The list of `Plates` is listed bellow
```{r Generate standard dataframes, echo=FALSE, warning=FALSE}
# No input required
  # Run previous "code" files sequentially
       # List all R files in the "code" folder
        code_files <- list.files("code", pattern = "*.R", full.names = TRUE)
        
        # Sort the files based on names (01, 02, 03, etc. )
          code_files <- sort(code_files)
        
        # Source each R file sequentially
        for (file in code_files) {
          source(file)
        }
  # Creation of standards dataframes ----
      #standards_df: all standards data from all paltes
          # Extract standards from all_plates_df
            standards_df <- all_plates_df[grep("Standard", all_plates_df$Sample), ]
          
          # Create Dilution factor column
            standards_df <- standards_df %>%
              mutate(Dilution_Factor = -as.numeric(str_extract(Sample, "\\d+")))

              # Move Dilution_Factor column to the second position
                standards_df <- standards_df %>%
                  select(Sample, Dilution_Factor, everything())  
          
          # Categorize MFI columns
            standard_mfi_cols <- names(standards_df)[sapply(standards_df, is.numeric) & names(standards_df) != "Dilution_Factor"]
          
          # Extract the part of the column name after "_"
            mfi_names <- gsub(".*_", "", standard_mfi_cols)
          
          # Gather MFI columns into long format
            standard_mfi_df <- tidyr::gather(standards_df, key = "Ab_Ag", value = "MFI", all_of(standard_mfi_cols))
          
          # Create Antigen groups
            standard_mfi_df <- standard_mfi_df %>%
              mutate(Antigen = gsub(".*_", "", Ab_Ag))
            
          # Create log10_MFI column (reduce later analysis errors)
            standard_mfi_df <- standard_mfi_df %>%
              mutate(log10_MFI = log10(MFI))
            
          #Create Plate column
              # Function to get Plate value for each row
                get_plate_value <- function(row) {
                  non_empty_values <- na.omit(row)
                  if (length(non_empty_values) == 0) {
                    return(NA_character_)
                  } else {
                    return(non_empty_values[1])
                  }
                }
              # Identify columns containing "Plate_"
                plate_cols <- grep("Plate_", names(standards_df), value = TRUE)
              
              # Create Plate column in standard_mfi_df
                standard_mfi_df <- standard_mfi_df %>%
                  mutate(Plate = apply(standard_mfi_df[plate_cols], 1, get_plate_value))
  
             # Create Antigen and Subclass columns based on Ab_Ag column
                standard_mfi_df <- standard_mfi_df %>%
                  mutate(
                    Subclass = sub("_.+", "", Ab_Ag),  # Extract what's before the "_"
                    Antigen = sub(".+_", "", Ab_Ag)    # Extract what's after the "_"
                  )
# show Plates 
    print(unique(standard_mfi_df$Plate))
    
```

# Standard curves for all antigens
This is the standard curve for each antigen. Pick which curve behaves logarithmically.

```{r Antigen standard curves, echo=FALSE, warning=FALSE}
# No input required    
     # Function to calculate correlation and R-squared for each subset
      calculate_correlation <- function(data) {
        complete_cases <- complete.cases(data$Dilution_Factor, data$log10_MFI)
        if (sum(complete_cases) < 2) { # Need at least 2 points for correlation
          return(data.frame(correlation = NA, r_squared = NA))
        }
        correlation <- cor(data$Dilution_Factor[complete_cases], data$log10_MFI[complete_cases], method = "pearson")
        r_squared <- correlation^2
        return(data.frame(correlation = correlation, r_squared = r_squared))
      }
      
      # Standard curves for each antigen
      plots <- standard_mfi_df %>%
        split(.$Antigen) %>%
        map(~ {
          # Check unique Subclass values
          print(unique(.x$Subclass))
          
          # Calculate correlation and R-squared for each Subclass
          correlation_values <- .x %>%
            group_by(Subclass) %>%
            do(calculate_correlation(.))
          # Create plot without filtering data and facet by Subclass
          ggplot(.x, aes(x = Dilution_Factor, y = log10_MFI, color = Subclass)) +
            geom_point() +
            geom_smooth(method = "lm", se = FALSE, color = "blue") +
            labs(x = "Dilution Factor", y = "log10(MFI)", color = "Subclass") +
            ggtitle(paste("MFI Standard curve for Antigen:", unique(.x$Antigen))) +
            theme_minimal() +
            facet_wrap(~ Subclass, scales = "free_y") +
            # Add R-squared values
            geom_text(data = correlation_values, aes(label = paste("R^2 =", round(r_squared, 2))),
                      x = Inf, y = -Inf, hjust = 1, vjust = 0)
        })
      
      # Print the plots
      print(plots)



```

# Standardization
Define your `standard_antigen` of interest. The code after this will create Log10(MFI) plots based on dilution factor

```{r Define standard antigen, warning=FALSE}
# Define the standard antigen
standard_antigen <- "AMA1"
```

```{r Standard Ag plots, echo=FALSE, warning=FALSE}
# No input required

    # Filter data for the standard antigen
    standard_filtered_data <- standard_mfi_df %>% 
      filter(Antigen == standard_antigen)
    
    # Filter out rows with zero dilution factor or NA MFI
    standard_filtered_data <- standard_filtered_data %>% 
      filter(Dilution_Factor != 0 & !is.na(log10_MFI))
    
    # Create a function to calculate correlation and R-squared for each subset
    calculate_correlation2 <- function(data) {
      correlation <- cor(data$Dilution_Factor, data$log10_MFI, method = "pearson")
      r_squared <- correlation^2
      return(data.frame(correlation = correlation, r_squared = r_squared))
    }
    
    # Calculate correlation and R-squared for each subset (facet)
    correlation_values2 <- standard_filtered_data %>%
      group_by(Subclass) %>%
      do(calculate_correlation2(.))
    
    # Create scatterplot with filtered data and facet by Subclass
    standard_plot <- ggplot(standard_filtered_data, aes(x = Dilution_Factor, y = log10_MFI)) +
      geom_point(aes(color = Plate)) +
      geom_smooth(method = "lm", se = FALSE, aes(group = Subclass), color = "blue") +  # Add line of best fit
      labs(x = "Dilution Factor", y = "log10(MFI)", color = "Plate") +
      ggtitle(paste("MFI Standard Curve for", standard_antigen, "based on Subclass")) +
      theme_minimal() +
      facet_wrap(~ Subclass, scales = "free_y") +
      # Add R-squared values
      geom_text(data = correlation_values2, aes(label = paste("R^2 =", round(r_squared, 2))),
                x = Inf, y = -Inf, hjust = 1, vjust = 0)
    
    # Print the plot
    print(standard_plot)


```

## MFI Correction

Pick a `Dilution_Factor` value that is within the linear range of the curve. This will be the `Reference_Dilution` 
For this study, we will use *-3* 
This reference dilution is used to calculate the `Correction_Factor`

### 1. Line of best fit for each plate

Using `standard_antigen`, we will plot and store the line of best for the standard curve from each plate. 

```{r Line of best fit- Plates, echo=FALSE, warning=FALSE}
# No input required
      # Calculate Pearson correlation coefficient and line of best fit equation
      correlation <- standard_filtered_data %>%
        group_by(Plate) %>%
        summarise(correlation = cor(Dilution_Factor, log10_MFI, method = "pearson"),
                  intercept = lm(log10_MFI ~ Dilution_Factor)$coefficients[1],
                  slope = lm(log10_MFI ~ Dilution_Factor)$coefficients[2])
      
      # Calculate R-squared value
      correlation$r_squared <- correlation$correlation^2
      
      # Plot with correlation text annotations
      ggplot(standard_filtered_data, aes(x = Dilution_Factor, y = log10_MFI)) +
        geom_point() +
        geom_smooth(method = "lm", se = FALSE, color = "blue") +
        labs(x = "Dilution Factor", y = "Log10(MFI)", 
             title = paste("Log10(MFI) of", standard_antigen, "based on dilution of pooled standard")) +
        facet_wrap(~Plate, scales = "free") +
        geom_text(data = correlation, aes(label = paste("R =", round(correlation, 2))),
                  x = Inf, y = -Inf, hjust = 1, vjust = 0)
      
      # Create a dataframe to store Plate, line of best fit equation, and R-squared values
      standards_plate_stats <- data.frame(
        Plate = correlation$Plate, Slope=correlation$slope, Y_intercept = correlation$intercept,
        Fit_line = paste("y =", round(correlation$slope, 2), "x +", round(correlation$intercept, 2)),
        R_squared = round(correlation$r_squared, 2)
      )
      
            # show columns
            selected_columns <- standards_plate_stats %>%
              select(Plate, Fit_line, R_squared)
            selected_columns

# Calculate average slope and intercept
average_slope <- mean(correlation$slope)
average_intercept <- mean(correlation$intercept)

    #Average fit line 
      # Create a single line of best fit equation using the average slope and intercept
average_fit_line <- paste("y =", round(average_slope, 2), "x +", round(average_intercept, 2))


```
### 2. Average line of best fit

The average line of best is `r average_fit_line`

### 3. Determine scaling factor

Select a `Dilution_Factor` within the linear log10(MFI) region of the `standard_antigen` of the standard curve. The `plate_scaling_factor` is determined as the ratio between the values of the plate line of best fit and the average line of best fit at that dilution. 
```{r echo=FALSE, warning=FALSE}
# Select a Dilution factor where the standard curves are consistently linear
scaling_dilution_factor <- -3

# No input required
      # Plate best fit line calculation for the dilution factor
      standards_plate_stats$bestfit_plate <- standards_plate_stats$Slope *scaling_dilution_factor + standards_plate_stats$Y_intercept
      
      #Average fit line calculation for the dilution factor
      standards_plate_stats$bestfit_all <- average_slope*scaling_dilution_factor + average_intercept
      
      standards_plate_stats$scaling_factor <- standards_plate_stats$bestfit_all/standards_plate_stats$bestfit_plate
      
    # display
    selected_columns <- standards_plate_stats %>%
      select(Plate, Fit_line, bestfit_plate, bestfit_all, scaling_factor)
    
    selected_columns
```

This assumes *linearity* of the correlation. The `bestfit_plate` is the `Fit_line` calculation for `scaling_dilution_factor`. The `bestfit_all` is the same calculation for the `average_fit_line`. The `scaling_factor` will be used on the MFI data from each plate in the compiled dataframe

#### Scaling dilution factor: `r scaling_dilution_factor`
#### Averaged fit line: `r average_fit_line`

